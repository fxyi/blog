import{_ as l,o as i,c as a,Q as e}from"./chunks/framework.2df22109.js";const b=JSON.parse('{"title":"一 绪论","description":"","frontmatter":{},"headers":[],"relativePath":"docs/数据库.md","filePath":"docs/数据库.md"}'),o={name:"docs/数据库.md"},r=e('<h1 id="一-绪论" tabindex="-1">一 绪论 <a class="header-anchor" href="#一-绪论" aria-label="Permalink to &quot;一 绪论&quot;">​</a></h1><h2 id="_1-2" tabindex="-1">1.2 <a class="header-anchor" href="#_1-2" aria-label="Permalink to &quot;1.2&quot;">​</a></h2><h3 id="_1-2-3-数据模型" tabindex="-1">1.2.3 数据模型 <a class="header-anchor" href="#_1-2-3-数据模型" aria-label="Permalink to &quot;1.2.3 数据模型&quot;">​</a></h3><ul><li>概念模型</li><li>逻辑模型</li><li>物理模型</li></ul><h3 id="_1-2-4-最常用的数据模型" tabindex="-1">1.2.4 最常用的数据模型 <a class="header-anchor" href="#_1-2-4-最常用的数据模型" aria-label="Permalink to &quot;1.2.4 最常用的数据模型&quot;">​</a></h3><p><strong>逻辑模型</strong></p><ul><li>层次模型：树形结构，组织架构图，家族族谱</li><li>网状模型：图形结构，工程图</li><li>关系模型：表格</li><li>面向对象模型</li><li>对象关系模型</li></ul><p>层次模型和网状模型又叫做格式化模型</p><h3 id="_1-2-5-关系模型" tabindex="-1">1.2.5 关系模型 <a class="header-anchor" href="#_1-2-5-关系模型" aria-label="Permalink to &quot;1.2.5 关系模型&quot;">​</a></h3><h4 id="_1、关系模型的数据结构" tabindex="-1">1、关系模型的数据结构 <a class="header-anchor" href="#_1、关系模型的数据结构" aria-label="Permalink to &quot;1、关系模型的数据结构&quot;">​</a></h4><ul><li>关系：对应一张表</li><li>元组：表中的一行，一条数据/记录</li><li>属性：表中的一列</li><li>码：键，可以唯一确定一个元组的属性</li><li>域：属性的取值范围/集合</li><li>分量：元组中的一个属性值</li><li>关系模式：对关系的描述，关系名(属性1，属性2，属性n)</li></ul><h4 id="_2、关系模型的操作与完整性约束" tabindex="-1">2、关系模型的操作与完整性约束 <a class="header-anchor" href="#_2、关系模型的操作与完整性约束" aria-label="Permalink to &quot;2、关系模型的操作与完整性约束&quot;">​</a></h4><ul><li>操作：查询，插入，删除，更新</li><li>完整性约束原则 <ul><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性</li></ul></li></ul><h4 id="_3、关系模型的优点" tabindex="-1">3、关系模型的优点 <a class="header-anchor" href="#_3、关系模型的优点" aria-label="Permalink to &quot;3、关系模型的优点&quot;">​</a></h4><ol><li>与格式化模型不同，关系模型是建立在严格的数学概念基础上的</li><li>概念单一</li><li>存取路径对用户透明，具备数据独立性、安全保密性</li></ol><h2 id="_1-3-数据库系统结构" tabindex="-1">1.3 数据库系统结构 <a class="header-anchor" href="#_1-3-数据库系统结构" aria-label="Permalink to &quot;1.3 数据库系统结构&quot;">​</a></h2><h3 id="_1-3-1-模式的概念" tabindex="-1">1.3.1 模式的概念 <a class="header-anchor" href="#_1-3-1-模式的概念" aria-label="Permalink to &quot;1.3.1 模式的概念&quot;">​</a></h3><p>模式（schema）：全体数据的逻辑结构和特征的描述</p><h3 id="_1-3-2-三级模式和两级映像" tabindex="-1">1.3.2 三级模式和两级映像 <a class="header-anchor" href="#_1-3-2-三级模式和两级映像" aria-label="Permalink to &quot;1.3.2 三级模式和两级映像&quot;">​</a></h3><ul><li>三级模式 <ol><li>外模式 - 应用/用户模式，视图</li><li>模式 - 概念/逻辑模式，实际数据库中是如何存储的，表长啥样</li><li>内模式 - 物理/存储模式，物理存储，数据索引</li></ol></li><li>两级映像：两种模式间的转换 <ol><li>内模式/模式映像</li><li>外模式/模式映像</li></ol></li></ul><h3 id="_1-3-3-数据独立性" tabindex="-1">1.3.3 数据独立性 <a class="header-anchor" href="#_1-3-3-数据独立性" aria-label="Permalink to &quot;1.3.3 数据独立性&quot;">​</a></h3><p>三级模式和两级映像保证了数据的独立性</p><h2 id="_1-4-数据库系统的组成" tabindex="-1">1.4 数据库系统的组成 <a class="header-anchor" href="#_1-4-数据库系统的组成" aria-label="Permalink to &quot;1.4 数据库系统的组成&quot;">​</a></h2><ol><li>数据库</li><li>数据库管理系统（及其开发工具）</li><li>应用系统</li><li>数据库管理员</li></ol><h1 id="二-关系数据库" tabindex="-1">二 关系数据库 <a class="header-anchor" href="#二-关系数据库" aria-label="Permalink to &quot;二 关系数据库&quot;">​</a></h1><h2 id="_2-1-关系数据结构及形式化定义" tabindex="-1">2.1 关系数据结构及形式化定义 <a class="header-anchor" href="#_2-1-关系数据结构及形式化定义" aria-label="Permalink to &quot;2.1 关系数据结构及形式化定义&quot;">​</a></h2><h3 id="_2-1-1-关系" tabindex="-1">2.1.1 关系 <a class="header-anchor" href="#_2-1-1-关系" aria-label="Permalink to &quot;2.1.1 关系&quot;">​</a></h3><p>现实世界中的实体，实体间的联系，都可以用关系来表示</p><p>逻辑结构是一张二维表</p><p>关系模型是建立在集合代数的基础上的</p><ol><li>域：属性的取值范围/集合</li><li>笛卡尔积：给定一组域，所有域的所有取值的一个组合。很多数据没有实际意义 <ul><li>元组 t：表中的一行，一条数据/记录</li><li>分量：元组中的一个属性值</li><li>基数：元组的个数，记录的条数</li><li>目/度 n：属性的个数</li></ul></li><li>关系：R(D1,D2,D3,Dn) <ul><li>单元关系：n=1，1个属性</li><li>二元关系：n=2，2个属性</li><li>码 <ul><li>候选码：凡是可以唯一确定一条记录的属性/属性组，比如学号、身份证号</li><li>全码：极端情况，表中所有属性才能决定一条记录</li><li>主码：从候选码中选一个作为主码</li><li>主属性：就是候选码</li><li>非主属性：不是候选码的</li></ul></li><li>三类关系/表 <ul><li>基本表：实际存储的表，其他都是虚拟表</li><li>查询表：查询结果对应的表</li><li>视图表：由基本表或其他视图表导出的表</li></ul></li><li>基本关系的性质</li></ul></li></ol><h3 id="_2-1-2-关系模式" tabindex="-1">2.1.2 关系模式 <a class="header-anchor" href="#_2-1-2-关系模式" aria-label="Permalink to &quot;2.1.2 关系模式&quot;">​</a></h3><p>关系模式是对关系的描述</p><ul><li>关系：R(D1,D2,D3,Dn)</li><li>关系模式：R(U,D,DOM,F) <ul><li>U：属性名集合</li><li>D：属性域的集合</li><li>DOM：U和D之间的映像关系</li><li>F：属性间的数据依赖关系</li></ul></li><li>关系模式是静态的，关系的动态的</li></ul><h3 id="_2-1-3-关系数据库" tabindex="-1">2.1.3 关系数据库 <a class="header-anchor" href="#_2-1-3-关系数据库" aria-label="Permalink to &quot;2.1.3 关系数据库&quot;">​</a></h3><ul><li>型：关系数据库的定义</li><li>模式：若干域的定义</li><li>值</li></ul><h3 id="_2-1-4-关系模型的存储结构" tabindex="-1">2.1.4 关系模型的存储结构 <a class="header-anchor" href="#_2-1-4-关系模型的存储结构" aria-label="Permalink to &quot;2.1.4 关系模型的存储结构&quot;">​</a></h3><ol><li>一个表对应一个操作系统文件</li><li>自己组织表、索引等存储结构</li></ol><h2 id="_2-2-关系数据结构" tabindex="-1">2.2 关系数据结构 <a class="header-anchor" href="#_2-2-关系数据结构" aria-label="Permalink to &quot;2.2 关系数据结构&quot;">​</a></h2><h3 id="_2-2-1-基本关系操作" tabindex="-1">2.2.1 基本关系操作 <a class="header-anchor" href="#_2-2-1-基本关系操作" aria-label="Permalink to &quot;2.2.1 基本关系操作&quot;">​</a></h3><ol><li>常用的关系操作 <ol><li>查询：选择、投影、连接、除、并、交、差 <ul><li>5种基本操作：选择、投影、并、差、笛卡尔积</li></ul></li><li>数据更新：插入、删除、修改</li></ol></li><li>关系操作的特点：集合的操作方式</li></ol><h3 id="_2-2-2-关系数据库语言的分类" tabindex="-1">2.2.2 关系数据库语言的分类 <a class="header-anchor" href="#_2-2-2-关系数据库语言的分类" aria-label="Permalink to &quot;2.2.2 关系数据库语言的分类&quot;">​</a></h3><ol><li>关系代数：用对关系的运算来表达查询要求，如 ISBL</li><li>关系演算语言：用谓词来表达查询要求 <ol><li>元组关系演算语言：APLHA</li><li>域关系演算语言：QBF</li></ol></li><li>具有关系代数和关系演算语言双重特点的语言：SQL</li></ol><h2 id="_2-3-关系的完整性" tabindex="-1">2.3 关系的完整性 <a class="header-anchor" href="#_2-3-关系的完整性" aria-label="Permalink to &quot;2.3 关系的完整性&quot;">​</a></h2><p>关系的两个不变性，必须满足：实体完整性，参照完整性</p><p><strong>三类完整性约束</strong></p><ol><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性</li></ol><h3 id="_2-3-1-实体完整性" tabindex="-1">2.3.1 实体完整性 <a class="header-anchor" href="#_2-3-1-实体完整性" aria-label="Permalink to &quot;2.3.1 实体完整性&quot;">​</a></h3><p>主属性不能取空，不能相同</p><h3 id="_2-3-2-参照完整性" tabindex="-1">2.3.2 参照完整性 <a class="header-anchor" href="#_2-3-2-参照完整性" aria-label="Permalink to &quot;2.3.2 参照完整性&quot;">​</a></h3><ol><li>关系间的引用</li><li>外码 <ol><li>参照关系</li><li>被参照关系/目标关系</li></ol></li><li>参照完整性规则 <ol><li>外码可以是空</li></ol></li></ol><h3 id="_2-3-3-用户定义的完整性" tabindex="-1">2.3.3 用户定义的完整性 <a class="header-anchor" href="#_2-3-3-用户定义的完整性" aria-label="Permalink to &quot;2.3.3 用户定义的完整性&quot;">​</a></h3><p>现实世界的语义要求</p><h2 id="_2-4-关系代数" tabindex="-1">2.4 关系代数 <a class="header-anchor" href="#_2-4-关系代数" aria-label="Permalink to &quot;2.4 关系代数&quot;">​</a></h2><p>关系代数是一种抽象的查询语言</p><p>运算的对象是关系/表，结果也是关系/表</p><p>根据运算符的不同进行分类</p><ul><li>集合运算：从关系的水平方向 <ul><li>并</li><li>差</li><li>交</li><li>笛卡尔积</li></ul></li><li>专门的关系运算：涉及行和列 <ul><li>选择</li><li>投影</li><li>连接：从两个关系的笛卡尔积中选出满足条件的元组</li><li>除</li></ul></li></ul><h3 id="_2-4-1-传统的集合运算" tabindex="-1">2.4.1 传统的集合运算 <a class="header-anchor" href="#_2-4-1-传统的集合运算" aria-label="Permalink to &quot;2.4.1 传统的集合运算&quot;">​</a></h3><p>两个结构一样的表</p><ol><li>并：R+S，数据在R里，也在S里</li><li>差：R-S，数据在R里，不在S里</li><li>交：R∩S，数据在R里，不在S里</li><li>笛卡尔积：两个结构可以不一样的表，R✖️S <ol><li>结果的列数是R的列数+S的列数</li><li>结果的元组个数为R的元组个数*S的元组个数</li></ol></li></ol><h3 id="_2-4-2-专门的关系运算" tabindex="-1">2.4.2 专门的关系运算 <a class="header-anchor" href="#_2-4-2-专门的关系运算" aria-label="Permalink to &quot;2.4.2 专门的关系运算&quot;">​</a></h3><p>关系R(A1,A2,A3,An)</p><p>t是R的一个元组</p><ol><li>选择：选择符合条件的元组</li><li>投影：选择指定列，返回不重复的可选值</li><li>连接：从两个关系的笛卡尔积中选出满足条件的元组 <ol><li>等值连接</li><li>自然连接：要求相等的两个属性名要相等</li></ol></li><li>除 <ol><li>R(X,Y) ➗ S(Y,Z) = P(X)</li></ol></li></ol><p><strong>四个概念</strong></p><ul><li>悬浮元组：两个关系R和S在进行自然连接时，不符合要求被舍弃的元组</li><li>外连接：悬浮元组也保存到结果中，其他属性为null</li><li>左外连接：只保留R的悬浮元组</li><li>右外连接：只保留S的悬浮元组</li></ul><h2 id="_2-5-关系演算" tabindex="-1">2.5 关系演算 <a class="header-anchor" href="#_2-5-关系演算" aria-label="Permalink to &quot;2.5 关系演算&quot;">​</a></h2><p>理论上的推导研究</p><p>关系演算是以数理逻辑中的谓词演算为基础的</p><ul><li>元组关系演算</li><li>域关系演算</li></ul><h3 id="_2-5-1-元组关系演算语言-alpha" tabindex="-1">2.5.1 元组关系演算语言： ALPHA <a class="header-anchor" href="#_2-5-1-元组关系演算语言-alpha" aria-label="Permalink to &quot;2.5.1 元组关系演算语言： ALPHA&quot;">​</a></h3><ol><li>检索操作：<strong>GET</strong>查询 <ol><li>简单检索（不带条件）</li><li>限定检索（带条件）</li><li>带排序的检索（DOWN降序，UP升序）</li><li>指定返回元组的个数</li><li>用元组变量的检索 <ol><li>简化关系名，重命名</li><li>操作条件中使用量词必须用元组变量</li><li>ALPHA语言用RANGE来说明元组变量</li></ol></li><li>用存在量词的检索条件中使用量词时必须使用元组变量</li><li>多个关系的表达式的检索</li><li>用全称量词的检索</li><li>用两种量词的检索</li><li>用蕴含的检索</li><li>聚集函数 <ol><li>count：会自动排除重复值</li><li>total</li><li>max</li><li>min</li><li>avg</li></ol></li></ol></li><li>更新操作 <ol><li>修改操作（并发） <ol><li>首先用<strong>HOLD</strong>语句将修改的元组从数据库中读取到工作空间中，HOLD有并发控制（锁），其他程序无法访问该数据</li><li>在工作空间中，用宿主语言修改元组属性：<strong>MOVE</strong>语句</li><li>用<strong>UPDATE</strong>语句将修改后的元组送回数据库</li><li>HLOLD和GET的关系：HOLD是带有并发的GET语句</li></ol></li><li>插入操作 <ol><li>用宿主语言MOVE语句，在工作空间中创建新的元组</li><li><strong>PUT</strong>将元组存入数据库</li></ol></li><li>删除操作 <ol><li>HLOD语句把要删除的元组从数据库中读到工作空间中</li><li><strong>DELETE</strong>删除该元组：删工作空间，删除数据库，解锁</li></ol></li></ol></li><li>DROP：删表</li></ol><h3 id="_2-5-2-元组关系演算" tabindex="-1">2.5.2 元组关系演算 <a class="header-anchor" href="#_2-5-2-元组关系演算" aria-label="Permalink to &quot;2.5.2 元组关系演算&quot;">​</a></h3><h3 id="_2-5-3-域关系演算语言qbe" tabindex="-1">2.5.3 域关系演算语言QBE <a class="header-anchor" href="#_2-5-3-域关系演算语言qbe" aria-label="Permalink to &quot;2.5.3 域关系演算语言QBE&quot;">​</a></h3><h1 id="三-关系数据库标准语言sql" tabindex="-1">三 关系数据库标准语言SQL <a class="header-anchor" href="#三-关系数据库标准语言sql" aria-label="Permalink to &quot;三 关系数据库标准语言SQL&quot;">​</a></h1>',76),t=[r];function h(n,d,s,u,c,_){return i(),a("div",null,t)}const p=l(o,[["render",h]]);export{b as __pageData,p as default};
